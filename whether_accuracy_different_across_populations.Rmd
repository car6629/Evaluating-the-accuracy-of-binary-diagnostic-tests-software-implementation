---
title: "Test whether accuracy of tests are different in different populations"
author: "Caroline"
date: "2025-11-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
suppressPackageStartupMessages(library(coda))
suppressPackageStartupMessages(library(rjags))
set.seed(12345L)
```

## R Markdown

```{r Two tests two populations with correlations}
library(rjags)

model_string <- "
model{
  # Priors
  Se1 ~ dbeta(24.09, 5.73)
  Sp1 ~ dbeta(23.05, 3.45)
  Se21 ~ dbeta(1, 1)
  Se20 ~ dbeta(1, 1)
  Sp21 ~ dbeta(1, 1)
  Sp20 ~ dbeta(1, 1)
  pi1 ~ dbeta(1.3, 5)
  pi2 ~ dbeta(1.5, 3)

  # Likelihood (2×2 tables per population)
  n1[1:4] ~ dmulti(p1[1:4], N1)
  n2[1:4] ~ dmulti(p2[1:4], N2)

  # Population 1 cell probabilities: (Y1,Y2) = (1,1),(1,0),(0,1),(0,0)
  p1[1] <- pi1*Se1*Se21 + (1-pi1)*(1-Sp1)*(1-Sp21)
  p1[2] <- pi1*Se1*(1-Se21) + (1-pi1)*(1-Sp1)*Sp21
  p1[3] <- pi1*(1-Se1)*Se20 + (1-pi1)*Sp1*(1-Sp20)
  p1[4] <- pi1*(1-Se1)*(1-Se20) + (1-pi1)*Sp1*Sp20

  # Population 2 (same Se/Sp, different prevalence)
  p2[1] <- pi2*Se1*Se21 + (1-pi2)*(1-Sp1)*(1-Sp21)
  p2[2] <- pi2*Se1*(1-Se21) + (1-pi2)*(1-Sp1)*Sp21
  p2[3] <- pi2*(1-Se1)*Se20 + (1-pi2)*Sp1*(1-Sp20)
  p2[4] <- pi2*(1-Se1)*(1-Se20) + (1-pi2)*Sp1*Sp20

  Se2 <- Se1*Se21 + Se20*(1-Se1)
  Sp2  <- Sp21*(1 - Sp1) + Sp20*Sp1
  corD <- (Se1*Se21 - Se1*Se2)/sqrt(Se1*(1 - Se1)*Se2*(1 - Se2))
  cornD <- (Sp20*Sp1 - Sp1*Sp2)/sqrt(Sp1*(1 - Sp1)*Sp2*(1 - Sp2))
}
"

data <- list()
data$n1 <- c(67, 25, 41, 329)
data$n2 <- c(97, 33, 36, 371)

# JAGS data list (order (11,10,01,00)) 
jdata <- list(
  n1 = data$n1, n2 = data$n2,
  N1 = sum(data$n1), N2 = sum(data$n2)
)

# Initial values 
inits_fun <- function() list(
  Se1 = runif(1, 0.5, 0.999),
  Sp1 = runif(1, 0.5, 0.999),
  Se21 = runif(1, 0.25, 0.999),
  Se20 = runif(1, 0.25, 0.999),
  Sp21 = runif(1, 0.25, 0.999),
  Sp20 = runif(1, 0.25, 0.999),
  pi1 = runif(1, 0.05, 0.95),
  pi2 = runif(1, 0.05, 0.95)
)

jm <- jags.model(textConnection(model_string),
                 data = jdata, inits = inits_fun, n.chains = 1, n.adapt = 2000)

# Burn-in
update(jm, 5000) 

samples <- coda.samples(jm,
                        variable.names = c("Se1","Sp1","Se2","Sp2", "pi1", "pi2", "corD", "cornD"),
                        n.iter = 30000)

s_summary <- summary(samples)
post_medians <- s_summary$quantiles[,"50%"] #Alternative median(samples[[1]][,1]) etc
post_q025  <- s_summary$quantiles[,"2.5%"]
post_q975  <- s_summary$quantiles[,"97.5%"]

post_summary <- data.frame(
  Median = post_medians,
  Q2.5 = post_q025,
  Q97.5 = post_q975
)

round(post_summary, 3)

post_all <- as.matrix(samples)




```



```{r Use two populations separately to test whether the accuracy is euqual}
model_string1 <- "
model{
  # Priors
  p1_Se1 ~ dbeta(24.09, 5.73)
  p1_Sp1 ~ dbeta(23.05, 3.45)
  p1_Se21 ~ dbeta(1, 1)
  p1_Se20 ~ dbeta(1, 1)
  p1_Sp21 ~ dbeta(1, 1)
  p1_Sp20 ~ dbeta(1, 1)
  pi1 ~ dbeta(1.3, 5)

  # Likelihood (2×2 tables per population)
  n1[1:4] ~ dmulti(p1[1:4], N1)

  # Population 1 cell probabilities: (Y1,Y2) = (1,1),(1,0),(0,1),(0,0)
  p1[1] <- pi1*p1_Se1*p1_Se21 + (1-pi1)*(1-p1_Sp1)*(1-p1_Sp21)
  p1[2] <- pi1*p1_Se1*(1-p1_Se21) + (1-pi1)*(1-p1_Sp1)*p1_Sp21
  p1[3] <- pi1*(1-p1_Se1)*p1_Se20 + (1-pi1)*p1_Sp1*(1-p1_Sp20)
  p1[4] <- pi1*(1-p1_Se1)*(1-p1_Se20) + (1-pi1)*p1_Sp1*p1_Sp20

  p1_Se2 <- p1_Se1*p1_Se21 + p1_Se20*(1-p1_Se1)
  p1_Sp2  <- p1_Sp21*(1 - p1_Sp1) + p1_Sp20*p1_Sp1
  p1_corD <- (p1_Se1*p1_Se21 - p1_Se1*p1_Se2)/sqrt(p1_Se1*(1 - p1_Se1)*p1_Se2*(1 - p1_Se2))
  p1_cornD <- (p1_Sp20*p1_Sp1 - p1_Sp1*p1_Sp2)/sqrt(p1_Sp1*(1 - p1_Sp1)*p1_Sp2*(1 - p1_Sp2))
}
"

model_string2 <- "
model{
  # Priors
  p2_Se1 ~ dbeta(24.09, 5.73)
  p2_Sp1 ~ dbeta(23.05, 3.45)
  p2_Se21 ~ dbeta(1, 1)
  p2_Se20 ~ dbeta(1, 1)
  p2_Sp21 ~ dbeta(1, 1)
  p2_Sp20 ~ dbeta(1, 1)
  pi2 ~ dbeta(1.5, 3)

  # Likelihood (2×2 tables per population)
  n2[1:4] ~ dmulti(p2[1:4], N2)

  # Population 2
  p2[1] <- pi2*p2_Se1*p2_Se21 + (1-pi2)*(1-p2_Sp1)*(1-p2_Sp21)
  p2[2] <- pi2*p2_Se1*(1-p2_Se21) + (1-pi2)*(1-p2_Sp1)*p2_Sp21
  p2[3] <- pi2*(1-p2_Se1)*p2_Se20 + (1-pi2)*p2_Sp1*(1-p2_Sp20)
  p2[4] <- pi2*(1-p2_Se1)*(1-p2_Se20) + (1-pi2)*p2_Sp1*p2_Sp20
  
  p2_Se2 <- p2_Se1*p2_Se21 + p2_Se20*(1-p2_Se1)
  p2_Sp2  <- p2_Sp21*(1 - p2_Sp1) + p2_Sp20*p2_Sp1
  p2_corD <- (p2_Se1*p2_Se21 - p2_Se1*p2_Se2)/sqrt(p2_Se1*(1 - p2_Se1)*p2_Se2*(1 - p2_Se2))
  p2_cornD <- (p2_Sp20*p2_Sp1 - p2_Sp1*p2_Sp2)/sqrt(p2_Sp1*(1 - p2_Sp1)*p2_Sp2*(1 - p2_Sp2))
}
"


data <- list()
data$n1 <- c(67, 25, 41, 329)
data$n2 <- c(97, 33, 36, 371)

# JAGS data list (order (11,10,01,00)) 
jdata1 <- list(
  n1 = data$n1, N1 = sum(data$n1)
)

jdata2 <- list(
  n2 = data$n2, N2 = sum(data$n2)
)

# Initial values 
inits_fun1 <- function() list(
  p1_Se1 = runif(1, 0.5, 0.999),
  p1_Sp1 = runif(1, 0.5, 0.999),
  p1_Se21 = runif(1, 0.25, 0.999),
  p1_Se20 = runif(1, 0.25, 0.999),
  p1_Sp21 = runif(1, 0.25, 0.999),
  p1_Sp20 = runif(1, 0.25, 0.999),
  pi1 = runif(1, 0.05, 0.95)
)

inits_fun2 <- function() list(
  p2_Se1 = runif(1, 0.5, 0.999),
  p2_Sp1 = runif(1, 0.5, 0.999),
  p2_Se21 = runif(1, 0.25, 0.999),
  p2_Se20 = runif(1, 0.25, 0.999),
  p2_Sp21 = runif(1, 0.25, 0.999),
  p2_Sp20 = runif(1, 0.25, 0.999),
  pi2 = runif(1, 0.05, 0.95)
)

jm1 <- jags.model(textConnection(model_string1),
                 data = jdata1, inits = inits_fun1, n.chains = 1, n.adapt = 2000)

jm2 <- jags.model(textConnection(model_string2),
                  data = jdata2, inits = inits_fun2, n.chains = 1, n.adapt = 2000)

# Burn-in
update(jm1, 5000) 
update(jm2, 5000)

samples1 <- coda.samples(jm1,
                        variable.names = c("p1_Se1","p1_Sp1","p1_Se2","p1_Sp2", "pi1", "p1_corD", "p1_cornD"),
                        n.iter = 30000)
samples2 <- coda.samples(jm2,
                         variable.names = c("p2_Se1","p2_Sp1","p2_Se2","p2_Sp2", "pi2", "p2_corD", "p2_cornD"),
                         n.iter = 30000)

s_summary1 <- summary(samples1)
s_summary2 <- summary(samples2)

post_medians_1 <- s_summary1$quantiles[,"50%"] #Alternative median(samples[[1]][,1]) etc
post_q025_1  <- s_summary1$quantiles[,"2.5%"]
post_q975_1  <- s_summary1$quantiles[,"97.5%"]
post_medians_2 <- s_summary2$quantiles[,"50%"] #Alternative median(samples[[1]][,1]) etc
post_q025_2  <- s_summary2$quantiles[,"2.5%"]
post_q975_2  <- s_summary2$quantiles[,"97.5%"]

post_summary1 <- data.frame(
  Median = post_medians_1,
  Q2.5 = post_q025_1,
  Q97.5 = post_q975_1
)

post_summary2 <- data.frame(
  Median = post_medians_2,
  Q2.5 = post_q025_2,
  Q97.5 = post_q975_2
)

round(post_summary1, 3)
round(post_summary2, 3)

post_all <- as.matrix(samples1)
post_all <- as.matrix(samples2)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
